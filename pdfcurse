#!/usr/bin/python3.7

import argparse
import sys
import os
import subprocess
import time
import curses
import threading

from pikepdf import Pdf


class PdfObj:
    """PDF file object in memory"""

    _fname = None
    _page = None
    _pages = 1
    _file_pages = None

    _buffer = None
    _error = None
    _stdscr = None
    _prevpage = None

    _gotkey = None
    _key = None

    _pollsec = 0.1
    _last_checked = None

    _scr = None
    _start_row = 0
    _start_col = 0
    _cont = False

    def __init__(self, fname):
        self._fname = fname
        self._page = 1
        pass


    def debug(self, txt):
        print(txt, file=sys.stderr)
        sys.stderr.flush()
        pass


    def check_file(self):
        try:
            with Pdf.open(self._fname) as pdf:
                page_count = len(pdf.pages)
            self._file_pages = page_count

        except:
            # ignore - file likely being compiled
            pass

        return self._file_pages


    def load(self, page):
        if page < 1: page = 1

        end_page = page + self._pages - 1
        if end_page > self._file_pages: end_page = self._file_pages
        if page > end_page: page = end_page

        cmd = ['/usr/bin/pdftotext', '-layout', #'-nopgbrk',
               '-f', str(page), '-l', str(end_page), self._fname, '-']
        p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        page_buffer, self._error = p.communicate()

        success = (p.returncode == 0)
        if success:
            self._page = page
            self._buffer = page_buffer.replace(b'\f', b'\n\n\n\n\n')
            self._last_checked = time.mktime(time.localtime())

        return success


    def paint(self, stdscr):
        lines = self._buffer.split(b'\n')

        nlines = min(len(lines) - self._start_row, curses.LINES)
        if nlines < curses.LINES and self._cont:
            if self._start_row > 0:
                self.load(self._page-1)
            else:
                self.load(self._page)

        stdscr.clear()
        try:
            for r in range(0,  nlines-1):
                row = lines[self._start_row+r]
                ncols = min(len(row) - self._start_col, curses.COLS)
                stdscr.addstr(r, 0, row[self._start_col:self._start_col+ncols])

        except IndexError as e:
            print(e)
            print(len(lines))

        stdscr.refresh()
        pass


    def listen(self):

        while True:
            key = self._scr.getch()
            self._gotkey = True
            self._key = key

        pass


    def browse(self, stdscr):

        if not self.check_file():
            return

        if not self.load(1):
            return

        curses.cbreak()
        self._scr = stdscr
        thread = threading.Thread(target=self.listen)
        thread.daemon = True
        thread.start()

        repaint = True
        while True:
            if repaint:
                self.paint(stdscr)

            time.sleep(self._pollsec)

            if self._gotkey:
                self._gotkey = False
                repaint = True

                if self._key == ord('q'): return

                elif self._key == curses.KEY_RESIZE:
                    self.debug('got resize')
                    curses.resizeterm(*stdscr.getmaxyx())

                # page navigation
                elif self._key == ord('f'): self.load(self._page+1)
                elif self._key == ord('a'): self.load(self._page-1)
                # todo: 'g'

                # horizontal panning
                elif self._key == ord('e') and self._start_col + 5 <= curses.COLS: self._start_col += 5
                elif self._key == ord('w') and self._start_col >= 5: self._start_col -= 5

                # vertical panning
                elif self._key == ord('v'):
                    if self._start_row + 5 <= curses.LINES:
                        self._start_row += 5
                    else:
                        self.load(self._page+1)

                elif self._key == ord('r'):
                    if self._start_row >= 5:
                        self._start_row -= 5
                    else:
                        self.load(self._page-1)

                # modes
                elif self._key == ord('c') and self._pages == 1:
                    self._pages = 2
                    self._cont = True
                    self.load(self._page)

                elif self._key == ord('1') and self._pages > 1:
                    self._pages = 1
                    self._cont = False
                    self.load(self._page)

                else:
                    #self.debug("Got key [{}]".format(self._key))
                    repaint = False
                continue

            modified = os.path.getmtime(self._fname)
            if modified > self._last_checked:
                if not self.check_file():
                    return
                self.load(self._page)
                repaint = True

        pass


def browse(stdscr, fname):
    pdf = PdfObj(fname)
    pdf.browse(stdscr)
    pass


def prepare_args():
    parser = argparse.ArgumentParser(description="PDF reader")
    parser.add_argument('file', type=str, help="pdf file to read")
    return parser


def main(args):
    curses.wrapper(browse, args.file)
    pass


if __name__ == "__main__":
    main(prepare_args().parse_args())

# end
